#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

#define NUM_CHILDREN 2

int main() {
    int fds[NUM_CHILDREN][2]; 
    pid_t pid;
    int child_index = -1;

    for (int i = 0; i < NUM_CHILDREN; i++) {
        if (pipe(fds[i]) == -1) {
            perror("Pipe failed");
            exit(1);
        }

        pid = fork();

        if (pid < 0) {
            perror("Fork failed");
            exit(1);
        }

        if (pid == 0) {
            // === CHILD LOGIC ===
            child_index = i;
            
            // 1. Close the WRITE end immediately because child only reads
            close(fds[i][1]); 
            
            // 2. Break to stop the child from looping and forking again
            break; 
        } else {
            // === PARENT LOGIC ===
            // 1. Close the READ end immediately because parent only writes
            close(fds[i][0]);
            
            // Parent continues the loop to fork the next child
        }
    }

    if (child_index != -1) {
        // --- This code runs ONLY in Child Processes ---
        char buffer[100];
        
        // Read from the specific pipe assigned to this child index
        ssize_t bytes_read = read(fds[child_index][0], buffer, sizeof(buffer) - 1);
        
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0'; // Ensure string is null-terminated
            printf("[Child %d] PID %d received: \"%s\"\n", child_index + 1, getpid(), buffer);
        }

        close(fds[child_index][0]); // Finished reading, close the door
        exit(0); 
    } else {
        // --- This code runs ONLY in the Parent Process ---
        printf("[Parent] PID %d sending tasks...\n\n", getpid());

        char *messages[] = {
            "Task Alpha: Scan the network",
            "Task Beta: Encrypt the database"
        };

        for (int i = 0; i < NUM_CHILDREN; i++) {
            write(fds[i][1], messages[i], strlen(messages[i]) + 1);
            
            // Once the message is sent, close the write end so the child sees "EOF"
            close(fds[i][1]);
        }

        // Wait for all children to finish
        for (int i = 0; i < NUM_CHILDREN; i++) {
            wait(NULL);
        }
        printf("\n[Parent] All children completed. System exiting.\n");
    }

    return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

#define NUM_CHILDREN 2

int main() {
    int fds[NUM_CHILDREN][2]; 
    pid_t pid;
    int child_index = -1;

    for (int i = 0; i < NUM_CHILDREN; i++) {
        if (pipe(fds[i]) == -1) {
            perror("Pipe failed");
            exit(1);
        }

        pid = fork();

        if (pid < 0) {
            perror("Fork failed");
            exit(1);
        }

        if (pid == 0) {
            // === CHILD LOGIC ===
            child_index = i;
            
            // 1. Close the WRITE end immediately because child only reads
            close(fds[i][1]); 
            
            // 2. Break to stop the child from looping and forking again
            break; 
        } else {
            // === PARENT LOGIC ===
            // 1. Close the READ end immediately because parent only writes
            close(fds[i][0]);
            
            // Parent continues the loop to fork the next child
        }
    }

    if (child_index != -1) {
        // --- This code runs ONLY in Child Processes ---
        char buffer[100];
        
        // Read from the specific pipe assigned to this child index
        ssize_t bytes_read = read(fds[child_index][0], buffer, sizeof(buffer) - 1);
        
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0'; // Ensure string is null-terminated
            printf("[Child %d] PID %d received: \"%s\"\n", child_index + 1, getpid(), buffer);
        }

        close(fds[child_index][0]); // Finished reading, close the door
        exit(0); 
    } else {
        // --- This code runs ONLY in the Parent Process ---
        printf("[Parent] PID %d sending tasks...\n\n", getpid());

        char *messages[] = {
            "Task Alpha: Scan the network",
            "Task Beta: Encrypt the database"
        };

        for (int i = 0; i < NUM_CHILDREN; i++) {
            write(fds[i][1], messages[i], strlen(messages[i]) + 1);
            
            // Once the message is sent, close the write end so the child sees "EOF"
            close(fds[i][1]);
        }

        // Wait for all children to finish
        for (int i = 0; i < NUM_CHILDREN; i++) {
            wait(NULL);
        }
        printf("\n[Parent] All children completed. System exiting.\n");
    }

    return 0;
}
